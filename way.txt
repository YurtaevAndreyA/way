

            Урок6
 1) Мы открыли наш проект
 2) В папке public находится файл index.html - он маленький
 3) Вся движуха происходит в папке src
 4) Заходим в src/app.js и видим там html, хотя это js файл
 5) Это придуманный в фейсбуке язык (как и сам react) - JSX, он позволяет
     писать html-код в js
 6) В src/app.js мы стерли класс и сделали стрелочную функцию (App) которая
     возвращает JSX (изменили его) - и страница изменилась!
 7) Если не закрыть тег JSX, то ругается компилятор, который преобразует JSX
     в js
 8) Добавили в стрелочную функцию пункты li-шки - страница опять
     изменилась
 9) У нас в файле app.js есть экспорты и импорты
10) Импортировать - значит вставить внутрь, экспортировать - это "во внешний
     мир"
11) ./ - это означает импортировать, что лежит в той же папке, что и я сейчас
     нахожусь
12) import './App.css' - файл App.css - лежит в той же папке, что и App.js и мы
     его импортируем
13) Заходим в App.css удаляем все старые стили и добавляем-играемся с новыми -
     страница меняется :)
14) Функция App возвращает разметку и эта разметка должна быть обязательно
     обернута в корневой узел (иначе компилятор будет ругаться)
15) Еще раз, функция App возвращает JSX разметку, она html, но поскольку она в
js-файле, то это jsx - html, встроенный в js


            Урок 7
 1) Компоненета - это функция, возвращающая разметку (JSX)
 2) Компонента может работать, много чего делать, но по итогу она должна
     возвращать разметку !!!
 3) Функция App является компонентой
 4) Компонента - это кирпичик из которого строится все
 5) Когда мы создаем компоненту у нас в реакте появляется новый тег
     <functionName /> и мы потом можем этот тег куда-то вставить
 6) Компоненета - это функция, возвращающая разметку, но это также тег !!!
 7) Мы компоненту руками никогда не вызываем, ни в коем случае, все что мы можем
     сделать - это вставить тег, а реакт далее все сделает за нас (вызовет
     функцию и т д)
 8) Файл public/index.html - в нем есть <div id="root"> (в body)
 9) У нас single page application - это значит, что наш index.html приходит в
     браузер единожды и много много джаваскрипта и этот джаваскрипт будет
     отрисовывать свое содержимое как раз таки внутри тега "див с айди рут"
10) Перед и после <div id="root"> можно что-нибудь написать - это докажет, что
     отрисовка происходит именно в этом теге
11) Идем в файл index.js - видим: ReactDOM.render(<App />, document
     .getElementById('root')); - это еще раз доказывает, что тег App вставляется
      в рут
12) Мы создали вторую компоненту Header и пока тег <Header /> никуда не
     вставлен, эта компонента не используется
13) Мы можем вставить тег <Header /> в компоненту App и в этом вся фишка !!! Вся
     разметка компоненты Header вставится в App
14) Таким образом вставленные компоненты поочереди отрисовываются реактом
15) Давайте все дробить !!! (Не очень мелко, а в здравом смысле)
16) Мы создали еще одну компоненту Technologies
18) Итак у нас в файле App.js три компоненты App, Header, Technologies и две
     последние вставлены в виде тегов в компоненту App, при этом прежнюю
     разметку из App мы удалили. Получается красивая, понятная и
     структурированная картина


            Урок 8
 1) Чтобы компоненты "не были в одной куче" мы будем для каждой создавать свой
     файл
 2) Чтобы использовать компоненту которой нет в данном файле, ее нужно
     импортировать: import componentName from 'path'
 3) Путь (относительный) начинается с данной папки: './   '
 4) Если нужно перейти на уровень вверх, то: './../   ' и т д
 5) Расширение файла можно не указывать, но на первых порах лучше писать: '
     ./file.js'
 6) Путь всегда пишется в кавычках
 7) При импорте модуля (например из папки node_modules) не нужно писать './ ', и
     не нужно указывать путь до него, а просто пишем название модуля !!!
 8) Итак импорт функции (компоненты) выглядит следующим образом: import My-file
     from './../../dir/folder/My-file.js'
 9) А импорт модуля - так: import Module from 'react'
10) Чтобы функцию можно было импортировать из другого файла, ее нужно
     экспортировать (во вне) из того файла: export default componentName
11) Если мы экспортируем по дефолту, то это значит мы экспортируем из этого
     файла что-то одно
12) Нужно потренироваться, чтобы сразу легко видеть, что импортируется в данный
файл и откуда и что экспортируется из него :)


            Урок 9
 1) Мы разносим наши компоненты по файлам, файл будет называться также как и
     компонента
 2) Мы создаем два файла Header.js и Technologies.js
 3) В каждом файле у нас соответственная компонента
 4) А также export default compName (в конце файла)
 5) И главное, чтоб мы могли использовать JSX в компонентах нужно импортировать
     модуль react в обои файлы: import React from 'react'
 6) В файл App.js сделаем импорт наших компонент: import Header from ./Header.js
     import Technologies from ./Technologies


            Урок 10
 1) Нужно быть очень внимательным и четко понимать откуда мы импортируем функцию
     (компоненту)
 2) Например, в "экспортном" файле у нас написано: export default Header, но при
     импорте мы можем написать вот так: import Abrakadabra from "./Header.js" и
     вставить тег <Abrakadabra /> и все будет работать.
 3) Т е Abrakadabra это просто какая то переменная и ее можно назвать как
     угодно, это происходит из-за экспорта по дефолту т е по умолчанию (или по
     определенному стандарту) Без default, надо полагать такого нет :)
 4) Поскольку пути к файлам бывают очень сложные, нужно настроить
     плагин-подсказку, когда пишешь тег-компоненту автоматически подсказывает
     возможный путь импорта


            Урок 11
 1) Теги-компоненты пишем обязательно с большой буквы !!!
 2) Например, если вместо <Header /> написать <header />, то он и отрисует
     <header />, т к это стандартный html-тег
 3) Начинаем верстать сеть с помощью grid (все "учебные" компоненты, которые
     были до этого, удаляем)
 4) Пока все верстаем в одном App.js файле, для простоты
 5) И получилось длиннющее полотно из дивов :))


            Урок 12
 1) Внутренний голос подсказывает: "Компоненты, используй компоненты!"
 2) Создаем отдельную папку components и создаем в ней файлы для компонент и
 сами компоненты, "копируя в них соответственные дивы из полотна"
 3) Очень важно научиться читать ошибки (где ошибка, какая)


            Урок 13
 1) Клонирование удаленного репо: git clone path (https.....)
 2) Можно клонировать через git bash, а можно webstorm - terminal
 3) В редакторе нужно открывать папку, открывать отдельные файлы - полная ерунда!!!
 4) Папка node_modules очень большая, поэтому мы не закидываем ее в репозиторий
     (удаленный и неудаленный), эта папка таким образом хранится у нас в .gitignore
 5) При клонировании проекта ее нужно скачать (по образу package.json): yarn
     install или npm install
 6) А затем уже можно запустить проект: yarn start или npm start (первая команда
     запускается у меня только в git bash и не запускается в ws-терминале, а вот
     npm start запускает, даже если проект создан c помощью менеджера yarn) [Это
     на ноуте, на компе и так и так работает] {На ноуте стоял nodejs v16 и
     create react app не грузился, я обновил nodejs до v18 и проект загрузился,
     но терминал работает коряво, частенько выдает ошибки, я прочитал в инете,
     что это возможно из-за использования последней версии. На компе стоит v16 и
     все норм}
 7) Если нужно (по работе) инсталлировать новый модуль, то нужно написать
     команду save, для того чтобы добавить этот модуль в package.json. А то
     иначе, люди, скачивая потом node_modules, окажутся без нашего нового модуля
     :)
 8) Команда gitk --all& открывает графический интерфейс, что позволяет
     визуализировать коммиты (работает в git bash, но не работает в ws-t)[На
     компе и так и так работает]
 9) Обычное копирование в буфер обмена (ctrl + c) тут не работает - нужно: ctr +
     insert (!!! - не забыть выделить мышью) и вставка shift + insert
10) Вернуться к нужному коммиту: git checkout commit-hash
11) Если в терминалах будет писаться лишнее при откате к коммиту, то файл
     package-lock.json - удалить
12) Когда мы откатились к одному из прошлых коммитов, мы не должны вносить
     какие-либо изменения, а только лишь просматривать код
13) Но если изменения все же будут (случайно), то гит даст нам знать об этом -
     при попытке переключиться на другой коммит или возвратиться в конец ветки
     гит прервет процесс и напишет, что есть изменения и нужно их вначале
     закоммитить
14) Если нажать в графическом интерфейсе F5, то там станут видны изменения в
     виде "отростка" :)
15) Команда checkout умеет убирать изменения: git checkout path-to-file (потом
     нажимаем опять F5 и видим - "отросток" убрался)
16) Эта команда работает, и когда мы находимся в "настоящем времени" т е
     когдас head указывает на ветку (находится в самом конце). Мы что-то пишем
     (какой-то код), и набрав git checkout path-to-file, просто возвратимся к
     тому, что зафиксировано последний раз.
17) Но это работает до добавления в стадию ожидания (git add .), если же мы уже
     добавили наш файл в ожидание, то нужно вывести сначала файл оттуда: git
     restore --stages filename, ну а потом git checkout path-to-file
18) Про удаление коммитов. Если коммиты локальные, то выбираем (левый нижний
     угол ws) Git, правой кнопкой мыши выбираем коммит из списка, Reset Current
     Branch, hard, reset - последние коммиты до выбранного будут удалены
19) Если коммиты удаленные, то в терминале: git reset HEAD^ (это последний
     коммит) или git reset HEAD~number (1 - последний, 2 - два последних и т д)
     и далее: git push -f вводим имя, пароль-токен и вуаля :)


