

            Урок6
1) Мы открыли наш проект
2) В папке public находится файл index.html - он маленький
3) Вся движуха происходит в папке src
4) Заходим в src/app.js и видим там html, хотя это js файл
5) Это придуманный в фейсбуке язык (как и сам react) - JSX,
    он позволяет писать html-код в js
6) В src/app.js мы стерли класс и сделали стрелочную функцию (App)
    которая возвращает JSX (изменили его) - и страница изменилась!
7) Если не закрыть тег JSX, то ругается компилятор, который преоб-
    разует JSX  в js
8) Добавили в стрелочную функцию путкты li-шки - страница опять
    изменилась
9) У нас в файле app.js есть экспорты и импорты
10) Заимпортировать - значит вставить внутрь, экспортировать - это
    "во внешний мир"
11) ./ - это означает импортировать, что лежит в той же папке, что и я
    сейчас нахожусь
12) import './App.css' - файл App.css - лежит в той же папке, что и
    App.js и мы его импортируем
13) Заходим в App.css удаляем все старые стили и добавляем-играемся
    с новыми - страница меняется :)
14) Функция App возвращает разметку и эта разметка должна быть
    обязательно обернута в корневой узел (иначе компилятор будет ругаться)
15) Еще раз, функция App возвращает JSX разметку, она html, но
    поскольку она в js-файле, то это jsx - html, встроенный в js


            Урок 7
1) Компоненета - это функция, возвращающая разметку (JSX)
2) Компонента может работать, много чего делать, но по итогу
    она должна возвращать разметку !!!
3) Фунция App является компонентой
4) Компонента - это кирпичик из которого строится все
5) Когда мы создаем компоненту у нас в реакте появляется
    новый тег <functionName /> и мы потом можем этот тег
    куда то вставить
6) Компоненета - это функция, возвращающая разметку,
    но это также тег !!!
7) Мы компоненту руками никогда не вызываем, не в коем случае,
    все что мы можем сделать это вставить тег, а реакт далее
    все сделает за нас (вызовет функцию и т д)
8) Файл public/index.html - в нем есть <div id="root"> (в body)
9) У нас single page application - это значит, что наш index.html
    приходит в браузер единожды и много много джаваскрипта
    и этот джаваскрипт будет отрисовывать свое содержимое
    как раз таки внутри тега "див с айди рут"
10) Перед и после <div id="root"> можно что-нибудь написать -
    это докажет, что отрисовка происходит именно в этом теге
11) Идем в файл index.js - видим: \
    ReactDOM.render(<App />, document.getElementById('root'));
    - это еще раз доказывает, что тег App вставляется в рут
12) Мы создали вторую компоненту Header и пока тег <Header />
    никуда не вставлен, эта компонента не используется
13) Мы можем вставить тег <Header /> в компоненту App
    и в этом вся фишка !!! Вся разметка компоненты Header
    вставится в App
14) Таким образом вставленные компоненты поочереди отрисовываются
    реактом
15) Давайте все дробить !!! (Не очень мелко, а в здравом смысле)
16) Мы создали еще одну компоненту Technologies
18) Итак у нас в файле App.js три компоненты App, Header, Technologies и
    две последние вставлены в виде тегов в компоненту App, при этом прежнюю
    разметку из App мы удалили. Получается красивая, понятная и
    структурированная картина


            Урок 8
1) Чтобы компоненты "не были в одной куче" мы будем для каждой
    создавать свой файл
2) Чтобы использовать компоненту которой нет в данном файле,
    ее нужно импортировать: \
    import componentName from 'path'
3) Путь (относительный) начинается с данной папки: './   '
4) Если нужно перейте на уровень вверх, то: './../   ' и т д
5) Расширение файла можно не указывать, но на первых порах
    лучше писать: './file.js'
6) Путь всегда пишется в кавычках
7) При импорте модуля (например из папки node_modules) не нужно
    писать './   ', и не нужно указывать путь до него,
    а просто пишем название модуля !!!
8) Итак импорт фунции (компоненты) выглядит следующим образом:
    import My-file from './../../dir/folder/My-file.js'
9) А импорт модуля - так: import Module from 'react'
10) Чтобы функцию можно было импортировать из другого файла,
    ее нужно экспортировать (во вне) из того файла:
    export default componentName
11) Если мы экспортируем по дефолту, то это значит мы
    экспортируем из этого файла что то одно
12) Нужно потренероваться, чтобы сразу легко видеть,
    что импортируется в данный файл и откуда и что
    экспортируется из него :)


            Урок 9
1) Мы разносим наши компоненты по файлам, файл будет называться
также как и компонента
2) Мы создаем два файла Header.js и Technologies.js
3) В каждом файле у нас соответственная компонента
4) А также export default compName (в конце файла)
5) И главное, чтоб мы могли использовать JSX в компонентах
    нужно импортировать модуль react в обои файлы:
    import React from 'react'
6) В файл App.js сделаем импорт наших компонент:
    import Header from ./Header.js
    import Technologies from ./Technologies


            Урок 10
1) Нужно быть очень внимательным и четко понимать
    откуда мы импортируем функцию (компоненту)
2) Например, в "экспортном" файле у нас написано:
    export default Header
    но при импорте мы можем написать вот так:
    import Abrakadabra from "./Header.js"
    и вставить тег <Abrakadabra /> и все будет
    работать.
3) Т е Abrakadabra это просто какая то переменная
    и ее можно назвать как угодно, это происходит
    из за экспорта по дефолту т е по умолчанию
    (или по определенному стандарту)
    Без default, надо полагать такого нет :)
4) Поскольку пути к файлам бывают очень сложные,
    нужно настроить плагин-подсказку, когда пишешь
    тег-компоненту автоматически подсказывает
    возможный путь импорта


            Урок 11
1) Теги-компоненты пишем обязательно с большой буквы !!!
2) Например, если вместо <Header /> написать <header />,
    то он и отрисует <header />, т к это стандартный
    html-тег
3) Начинаем верстать сеть с помощью grid (все "учебные"
    компоненты, которые были до этого, удаляем)
4) Пока все верстаем в одном App.js файле, для простоты
5) И получилось длиннющее полотно из дивов :))


            Урок 12
1) Внутренний голос подсказывает: "Компоненты, используй компоненты!"
2) Создаем отдельную папку components и создаем в ней файлы
    для компонент и сами компоненты, "копируя в них соответственные дивы
    из полотна"
3) Очень важно научиться читать ошибки (где ошибка, какая)



            Урок 13
1) Клонирование удаленного репо: git clone path (https.....)

2) Можно клонировать через git bash, а можно webstorm - terminal

3) В редакторе нужно открывать папку, открывать отдельные файлы - полная ерунда !!!

4) Папка node_modules очень большая, поэтому мы не закидываем ее в репозиторий (удаленный и неудаленный), эта папка таким образом хранится у нас в .gitignore

5) При клонировании проекта ее нужно скачать (по образу package.json): yarn install или npm install

6) А затем уже можно запустить проект: yarn start или npm start (первая команда
запускается у меня только в git bash и не запускается в ws-терминале, а вот npm
start запускает, даже если проект создан c помощью менеджера yarn)
[Это на ноуте, на компе и так и так работает]
{На ноуте стоял nodejs v16 и create react app не
 грузился, я обновил nodejs до v18 и проект загрузился, но терминал работает
 коряво, частенько выдает ошибки, я прочитал в инете, что это возможно из-за
 использования последней версии. На компе стоит v16 и все норм}

7) Если нужно (по работе) инсталировать новый модуль, то нужно написать команду
save, для того чтобы добавить этот модуль в package.json. А то иначе, люди,
скачивая потом node_modules, окажутся без нашего нового модуля :)

8) Команда gitk --all& открывает графический интерфейс, что позволяет
визуализировать коммиты (работает в git bash, но не работае в ws-t)[На компе и
так и так]

9) Обычное копирование в буфер обмена (ctrl + c) тут не работает - нужно: ctrl + insert (!!! - не зыбыть выделить мышью) и вставка shift + insert

10) Вернуться к нужному коммиту: git checkout commit-hash

11) Если в терминалах будет писаться лишнее при откате к коммиту, то файл package-lock.json - удалить

12) Когда мы откатились к одному из прошлых коммитов, мы не должны вносить
какие-либо изменения, а только лишь просматривать код

13) Но если изменения все же будут (случайно), то гит даст нам знать об этом -
при попытке переключиться на другой коммит или возвратиться к в конец ветки гит
прервет процесс и напишет, что есть изменения и нужно их вначале закоммитить

14) Если нажать в графическом интерфейсе F5, то там станут видны изменения в
виде отростка :)

15) Команда checkout умеет убирать изменения: git checkout path-to-file (потом
нажимаем опять F5 и видим - отросток убрался)

16) Эта команда работает и когда мы находимся в "настоящем времени" т е когда
head указывает на ветку (находится в самом конце). Мы что-то пишем (какой то
код), и набрав git checkout path-to-file, просто возвратимся к тому, что
зафиксировано последний раз.

17) Но это работает до добавления в стадию ожидания (git add .), если же мы уже
добавили наш файл в ожидание, то нужно вывести сначало файл оттуда: git restore
--stages filename, ну а потом git checkout path-to-file

18) Про удаление коммитов. Если коммиты локальные, то выбираем (левый нижний
угол ws) Git, правой кнопкой мыши выбираем коммит из списка, Reset Current
Branch, hard, reset - последние коммиты до выбранного будут удалены

19) Если коммиты удаленные, то в терминале: git reset HEAD^ (это последний
коммит) или git reset HEAD~number (1 - последний, 2 - два последних и т д) и
далее: git push -f вводим имя, пароль-токен и вуаля :)