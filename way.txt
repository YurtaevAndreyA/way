

            Урок6
 1) Мы открыли наш проект
 2) В папке public находится файл index.html - он маленький
 3) Вся движуха происходит в папке src
 4) Заходим в src/app.js и видим там html, хотя это js файл
 5) Это придуманный в фейсбуке язык (как и сам react) - JSX, он позволяет
     писать html-код в js
 6) В src/app.js мы стерли класс и сделали стрелочную функцию (App) которая
     возвращает JSX (изменили его) - и страница изменилась!
 7) Если не закрыть тег JSX, то ругается компилятор, который преобразует JSX
     в js
 8) Добавили в стрелочную функцию пункты li-шки - страница опять
     изменилась
 9) У нас в файле app.js есть экспорты и импорты
10) Импортировать - значит вставить внутрь, экспортировать - это "во внешний
     мир"
11) ./ - это означает импортировать, что лежит в той же папке, что и я сейчас
     нахожусь
12) import './App.css' - файл App.css - лежит в той же папке, что и App.js и мы
     его импортируем
13) Заходим в App.css удаляем все старые стили и добавляем-играемся с новыми -
     страница меняется :)
14) Функция App возвращает разметку и эта разметка должна быть обязательно
     обернута в корневой узел (иначе компилятор будет ругаться)
15) Еще раз, функция App возвращает JSX разметку, она html, но поскольку она в
js-файле, то это jsx - html, встроенный в js


            Урок 7
 1) Компоненета - это функция, возвращающая разметку (JSX)
 2) Компонента может работать, много чего делать, но по итогу она должна
     возвращать разметку !!!
 3) Функция App является компонентой
 4) Компонента - это кирпичик из которого строится все
 5) Когда мы создаем компоненту у нас в реакте появляется новый тег
     <functionName /> и мы потом можем этот тег куда-то вставить
 6) Компоненета - это функция, возвращающая разметку, но это также тег !!!
 7) Мы компоненту руками никогда не вызываем, ни в коем случае, все что мы можем
     сделать - это вставить тег, а реакт далее все сделает за нас (вызовет
     функцию и т д)
 8) Файл public/index.html - в нем есть <div id="root"> (в body)
 9) У нас single page application - это значит, что наш index.html приходит в
     браузер единожды и много много джаваскрипта и этот джаваскрипт будет
     отрисовывать свое содержимое как раз таки внутри тега "див с айди рут"
10) Перед и после <div id="root"> можно что-нибудь написать - это докажет, что
     отрисовка происходит именно в этом теге
11) Идем в файл index.js - видим: ReactDOM.render(<App />, document
     .getElementById('root')); - это еще раз доказывает, что тег App вставляется
      в рут
12) Мы создали вторую компоненту Header и пока тег <Header /> никуда не
     вставлен, эта компонента не используется
13) Мы можем вставить тег <Header /> в компоненту App и в этом вся фишка !!! Вся
     разметка компоненты Header вставится в App
14) Таким образом вставленные компоненты поочереди отрисовываются реактом
15) Давайте все дробить !!! (Не очень мелко, а в здравом смысле)
16) Мы создали еще одну компоненту Technologies
18) Итак у нас в файле App.js три компоненты App, Header, Technologies и две
     последние вставлены в виде тегов в компоненту App, при этом прежнюю
     разметку из App мы удалили. Получается красивая, понятная и
     структурированная картина


            Урок 8
 1) Чтобы компоненты "не были в одной куче" мы будем для каждой создавать свой
     файл
 2) Чтобы использовать компоненту которой нет в данном файле, ее нужно
     импортировать: import componentName from 'path'
 3) Путь (относительный) начинается с данной папки: './   '
 4) Если нужно перейти на уровень вверх, то: './../   ' и т д
 5) Расширение файла можно не указывать, но на первых порах лучше писать: '
     ./file.js'
 6) Путь всегда пишется в кавычках
 7) При импорте модуля (например из папки node_modules) не нужно писать './ ', и
     не нужно указывать путь до него, а просто пишем название модуля !!!
 8) Итак импорт функции (компоненты) выглядит следующим образом: import My-file
     from './../../dir/folder/My-file.js'
 9) А импорт модуля - так: import Module from 'react'
10) Чтобы функцию можно было импортировать из другого файла, ее нужно
     экспортировать (во вне) из того файла: export default componentName
11) Если мы экспортируем по дефолту, то это значит мы экспортируем из этого
     файла что-то одно
12) Нужно потренироваться, чтобы сразу легко видеть, что импортируется в данный
файл и откуда и что экспортируется из него :)


            Урок 9
 1) Мы разносим наши компоненты по файлам, файл будет называться также как и
     компонента
 2) Мы создаем два файла Header.js и Technologies.js
 3) В каждом файле у нас соответственная компонента
 4) А также export default compName (в конце файла)
 5) И главное, чтоб мы могли использовать JSX в компонентах нужно импортировать
     модуль react в обои файлы: import React from 'react'
 6) В файл App.js сделаем импорт наших компонент: import Header from ./Header.js
     import Technologies from ./Technologies


            Урок 10
 1) Нужно быть очень внимательным и четко понимать откуда мы импортируем функцию
     (компоненту)
 2) Например, в "экспортном" файле у нас написано: export default Header, но при
     импорте мы можем написать вот так: import Abrakadabra from "./Header.js" и
     вставить тег <Abrakadabra /> и все будет работать.
 3) Т е Abrakadabra это просто какая то переменная и ее можно назвать как
     угодно, это происходит из-за экспорта по дефолту т е по умолчанию (или по
     определенному стандарту) Без default, надо полагать такого нет :)
 4) Поскольку пути к файлам бывают очень сложные, нужно настроить
     плагин-подсказку, когда пишешь тег-компоненту автоматически подсказывает
     возможный путь импорта


            Урок 11
 1) Теги-компоненты пишем обязательно с большой буквы !!!
 2) Например, если вместо <Header /> написать <header />, то он и отрисует
     <header />, т к это стандартный html-тег
 3) Начинаем верстать сеть с помощью grid (все "учебные" компоненты, которые
     были до этого, удаляем)
 4) Пока все верстаем в одном App.js файле, для простоты
 5) И получилось длиннющее полотно из дивов :))


            Урок 12
 1) Внутренний голос подсказывает: "Компоненты, используй компоненты!"
 2) Создаем отдельную папку components и создаем в ней файлы для компонент и
 сами компоненты, "копируя в них соответственные дивы из полотна"
 3) Очень важно научиться читать ошибки (где ошибка, какая)


            Урок 13
 1) Клонирование удаленного репо: git clone path (https.....)
 2) Можно клонировать через git bash, а можно webstorm - terminal
 3) В редакторе нужно открывать папку, открывать отдельные файлы - полная ерунда!!!
 4) Папка node_modules очень большая, поэтому мы не закидываем ее в репозиторий
     (удаленный и неудаленный), эта папка таким образом хранится у нас в .gitignore
 5) При клонировании проекта ее нужно скачать (по образу package.json): yarn
     install или npm install
 6) А затем уже можно запустить проект: yarn start или npm start (первая команда
     запускается у меня только в git bash и не запускается в ws-терминале, а вот
     npm start запускает, даже если проект создан c помощью менеджера yarn) [Это
     на ноуте, на компе и так и так работает] {На ноуте стоял nodejs v16 и
     create react app не грузился, я обновил nodejs до v18 и проект загрузился,
     но терминал работает коряво, частенько выдает ошибки, я прочитал в инете,
     что это возможно из-за использования последней версии. На компе стоит v16 и
     все норм}
 7) Если нужно (по работе) инсталлировать новый модуль, то нужно написать
     команду save, для того чтобы добавить этот модуль в package.json. А то
     иначе, люди, скачивая потом node_modules, окажутся без нашего нового модуля
     :)
 8) Команда gitk --all& открывает графический интерфейс, что позволяет
     визуализировать коммиты (работает в git bash, но не работает в ws-t)[На
     компе и так и так работает]
 9) Обычное копирование в буфер обмена (ctrl + c) тут не работает - нужно: ctr +
     insert (!!! - не забыть выделить мышью) и вставка shift + insert
10) Вернуться к нужному коммиту: git checkout commit-hash
11) Если в терминалах будет писаться лишнее при откате к коммиту, то файл
     package-lock.json - удалить
12) Когда мы откатились к одному из прошлых коммитов, мы не должны вносить
     какие-либо изменения, а только лишь просматривать код
13) Но если изменения все же будут (случайно), то гит даст нам знать об этом -
     при попытке переключиться на другой коммит или возвратиться в конец ветки
     гит прервет процесс и напишет, что есть изменения и нужно их вначале
     закоммитить
14) Если нажать в графическом интерфейсе F5, то там станут видны изменения в
     виде "отростка" :)
15) Команда checkout умеет убирать изменения: git checkout path-to-file (потом
     нажимаем опять F5 и видим - "отросток" убрался)
16) Эта команда работает, и когда мы находимся в "настоящем времени" т е
     когдас head указывает на ветку (находится в самом конце). Мы что-то пишем
     (какой-то код), и набрав git checkout path-to-file, просто возвратимся к
     тому, что зафиксировано последний раз.
17) Но это работает до добавления в стадию ожидания (git add .), если же мы уже
     добавили наш файл в ожидание, то нужно вывести сначала файл оттуда: git
     restore --stages filename, ну а потом git checkout path-to-file
18) Про удаление коммитов. Если коммиты локальные, то выбираем (левый нижний
     угол ws) Git, правой кнопкой мыши выбираем коммит из списка, Reset Current
     Branch, hard, reset - последние коммиты до выбранного будут удалены
19) Если коммиты удаленные, то в терминале: git reset HEAD^ (это последний
     коммит) или git reset HEAD~number (1 - последний, 2 - два последних и т д)
     и далее: git push -f вводим имя, пароль-токен и вуаля :)


           Урок 14
 1) Есть несколько способов как организовать работу со стилями css
 2) Можно использовать вложенности (.header img) или БЭМ-методологию
 3) Но мы воспользуемся концепцией модулей, натроенной в окружении реакта
 4) Модули хороши тем, что в каждом из них можно давать простые и одинаковые
     названия, без них с названиями пришлось бы сильно заморочиться
 5) Мы уже разнесли компоненты по различным файлам (Header.jsx, Navbar.jsx,
     Profile.jsx), давайте теперь разнесем css-код также по отдельным файлам
     (Header.css, Navbar.css, Profile.css)
 6) И импортируем файлы css в файлы jsx (например в Header.jsx напишем: import '
     ./Header.css';
 7) Хотя есть такой тренд не ставить ";" в конце строки, но мы пока будем
     ставить
 8) Уже получилось неплохо, код стал структурирован. Загвоздка заключается в
     том, что если мы сделаем одинаковые классы (className) в разных css-файлах,
     то стили применятся одинаково ко всем таким одинаковым классам
 9) Объяснение заключается в том, что у нас (в реакте) на самом деле нет никаких
     css-классов, код в итоге весь склеивается и попадает в один набор стилей на
     нашу единственную страницу html. Таким образом структурированность является
     в этом случае, чисто условной, на самом деле все стили глобальны
10) В create-react-app есть настройка модулей. Чтоб этим воспользоваться, нужно
     в название каждого css-файла записать слово "module" (Header.module.css).
     И также это название нужно использовать в импорте: import classes './Header
     .module.css'
11) У нас появилось слово "classes". Это специалный объект.
12) Когда мы написали - module, названия наших слассов модифицировались (это
     можно посмотреть в файле index.html в теге style), к названиям классов
     прибаляются префиксы (название компоненты) и постфиксы (рандомная строчка).
     Т е у нас в коде одно название, а по факту другое - и стили не применятся
     (без объекта classes)
13) Можно, посмотрев, новое название класса (в файле index.html) вставить его
     вместо старого названия ради эксперимента
     (className='Header_нашеНазвание__randomStr'), тогда стили сработают, но так
     делать каждый раз совершенно неудобно. Вот для этого нам и нужен объект
     classes
14) Объект classes, кстати говоря может быть назван как угодно, какое название
     подставим - import LLLLL './Header.module.css', так и будет называться.
     Так вот, ключами этого объекта будут старые имена, а значениями - новые,
     поэтому мы напишем так: import LLLLL from './Header.module.css';
     А в названиях классах функции-компоненты: className='LLLL.староеНазвание'..
15) JS-выражения в JSX пишутся в фигурных скобках, так что правильно будет так:
     <тег className={LLLLL.староеНазвание}>  </тег>
16) Мы переделаем все ccs-файлы в модули, но некоторые (глобальные, такой как
     App.css) лучше оставить как есть
17) Чтоб применить два (и более) класса пишем:
     className={LLLLL.староеНазвание1 + ' ' + LLLLL.староеНазвание2} или
     className={ {`LLLLL.староеНазвание1} + {LLLLL.староеНазвание2}` }
     во втором варианте мы воспользовались современным синтаксисом под названием
     - "шаблонная строка"
18) Мы можем посмотреть наш объект, выведя его в консоль - console.log(LLLLL)
19) Мы не используем в названиях стилей дефис, а вместо него нижнее
     подчеркивание или верблюжью нотацию. Это связано с тем, что чтобы
     обратиться к свойству объекту через точку (к названию свойства), оно должно
     соответствовать правилам названия переменной, а именно: не начинаться с
     цифры, содержать любые буквы или цифры, а также символы "$", "_". Для
     замороченных названий используются "[]", но нам проще не использовать дефис


            Урок 15
 1) Наводим порядок. В папке compontnts создадим папки Header, Navbar, Profile и
     в каждую положим по два файла с соответствующим названием (в Header -
     Header.jsx и Header.module.css и т д)
 2) Когда мы перекладываем, то наши импотры "летят" т к меняется вложенность,
     неплохо было бы научиться, чтобы импорты испралялись "автоматом"
 3) Далее, мы продолжаем дробить!!! Внутри папок Header, Navbar, Profil мы
     создаем другие папки со своими компонентами и стилями, а внутри этих
     других, еще другие и т д и т д. Таким образом наши компоненты получаются
     максимально маленькими и простыми
 4) Внутри папки Profile мы создаем папку MyPosts, в ней файлы MyPosts.module
     .css и MyPosts.jsx и папку Post и в ней два файла Post.module.css и Post
     .jsx
 5) То есть у нас компонента MyPosts используется внутри компоненты Profile. И
     несколько компонент Post внутри MyPost. Компонент Post - несколько, а текст
     у них один и тот же, который написан внутри Post, как же быть и сделать
     систему более гибкой? Это делается с помощью пропсов, о них в следующим
     уроке

